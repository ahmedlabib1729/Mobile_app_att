# -*- coding: utf-8 -*-

from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import logging

_logger = logging.getLogger(__name__)


class AccountMove(models.Model):
    """
    Extension of account.move to handle automatic intercompany entry creation.

    When a journal entry is posted and contains Related Party accounts,
    this module will automatically create corresponding entries in the
    related companies.
    """
    _inherit = 'account.move'

    # Technical field to prevent infinite loops
    skip_intercompany = fields.Boolean(
        string='Skip Intercompany Processing',
        default=False,
        copy=False,
        help="Technical field: Prevents infinite loop when creating intercompany entries"
    )

    # Link to source move (if this was auto-generated)
    source_intercompany_move_id = fields.Many2one(
        'account.move',
        string='Source Intercompany Move',
        copy=False,
        readonly=True,
        help="The original move that triggered this intercompany entry"
    )

    # Computed field to check if this is an intercompany generated move
    is_intercompany_generated = fields.Boolean(
        string='Intercompany Generated',
        compute='_compute_is_intercompany_generated',
        store=True,
        help="Indicates if this entry was automatically generated by intercompany module"
    )

    # Count of related intercompany moves
    related_intercompany_count = fields.Integer(
        string='Related Intercompany Entries',
        compute='_compute_related_intercompany_count',
        help="Number of intercompany entries related to this move"
    )

    # IDs of related intercompany moves
    related_intercompany_move_ids = fields.Many2many(
        'account.move',
        'account_move_intercompany_rel',
        'source_move_id',
        'target_move_id',
        string='Related Intercompany Moves',
        compute='_compute_related_intercompany_moves',
        help="All intercompany moves related to this move"
    )

    @api.depends('source_intercompany_move_id')
    def _compute_is_intercompany_generated(self):
        """Check if this move was auto-generated"""
        for move in self:
            move.is_intercompany_generated = bool(move.source_intercompany_move_id)

    def _compute_related_intercompany_count(self):
        """Count related intercompany moves"""
        for move in self:
            # Find moves where this is the source
            generated_moves = self.search([
                ('source_intercompany_move_id', '=', move.id)
            ])
            # Find the source move if this is generated
            source_moves = self.search([
                ('id', '=', move.source_intercompany_move_id.id)
            ]) if move.source_intercompany_move_id else self.browse()

            move.related_intercompany_count = len(generated_moves) + len(source_moves)

    def _compute_related_intercompany_moves(self):
        """Get all related intercompany moves"""
        for move in self:
            related_moves = self.browse()

            # If this is a generated move, get the source
            if move.source_intercompany_move_id:
                related_moves |= move.source_intercompany_move_id
                # Also get other moves generated from the same source
                related_moves |= self.search([
                    ('source_intercompany_move_id', '=', move.source_intercompany_move_id.id),
                    ('id', '!=', move.id)
                ])
            else:
                # This is a source move, get all generated moves
                related_moves |= self.search([
                    ('source_intercompany_move_id', '=', move.id)
                ])

            move.related_intercompany_move_ids = related_moves

    def action_post(self):
        """
        Override action_post to trigger intercompany entry creation.

        This method is called when a move is posted. After the normal posting,
        we check if the move contains Related Party accounts and create
        corresponding entries in other companies.
        """
        # Call the original action_post
        res = super(AccountMove, self).action_post()

        # Process intercompany entries for moves that were just posted
        for move in self:
            # Only process if:
            # 1. Move is posted
            # 2. Not flagged to skip intercompany processing
            # 3. Not already an intercompany generated move (extra safety)
            if move.state == 'posted' and not move.skip_intercompany:
                try:
                    move._create_intercompany_entries()
                except Exception as e:
                    # Log the error but don't block the posting
                    _logger.error(
                        'Failed to create intercompany entries for move %s: %s',
                        move.name,
                        str(e)
                    )
                    # Optionally: create an activity/notification for the user
                    move._notify_intercompany_error(str(e))

        return res

    def _create_intercompany_entries(self):
        """
        Main method to analyze the move and create intercompany entries.

        This method:
        1. Identifies Related Party lines
        2. Groups them by target company
        3. Creates journal entries in each target company
        """
        self.ensure_one()

        _logger.info('Processing intercompany entries for move: %s', self.name)

        # Get Related Party lines grouped by target company
        rp_lines_by_company = self._get_related_party_lines_grouped()

        if not rp_lines_by_company:
            _logger.debug('No related party lines found in move: %s', self.name)
            return

        _logger.info(
            'Found related party lines for %d companies in move: %s',
            len(rp_lines_by_company),
            self.name
        )

        # Create entries for each target company
        created_moves = self.browse()
        for target_company, lines_data in rp_lines_by_company.items():
            try:
                new_move = self._create_entry_for_company(target_company, lines_data)
                created_moves |= new_move
                _logger.info(
                    'Successfully created intercompany move %s in company %s',
                    new_move.name,
                    target_company.name
                )
            except Exception as e:
                _logger.error(
                    'Failed to create intercompany entry for company %s: %s',
                    target_company.name,
                    str(e)
                )
                # Continue with other companies even if one fails
                continue

        if created_moves:
            _logger.info(
                'Created %d intercompany moves for source move: %s',
                len(created_moves),
                self.name
            )

    def _get_related_party_lines_grouped(self):
        """
        Analyze move lines and identify Related Party accounts.

        Returns:
            dict: {target_company: [line_data, ...]}
        """
        self.ensure_one()

        result = {}

        # Get all active configurations for this company
        configs = self.env['intercompany.config'].search([
            ('company_id', '=', self.company_id.id),
            ('active', '=', True)
        ])

        if not configs:
            return result

        # Create mapping: account_id -> config
        account_config_map = {config.account_id.id: config for config in configs}

        # Process each line in the move
        for line in self.line_ids:
            # Skip reconciled lines or lines without amount
            if not line.debit and not line.credit:
                continue

            # Check if this line uses a Related Party account
            if line.account_id.id in account_config_map:
                config = account_config_map[line.account_id.id]
                target_company = config.target_company_id

                # Initialize list for this company if needed
                if target_company not in result:
                    result[target_company] = []

                # Extract line data
                line_data = {
                    'config': config,
                    'line': line,
                    'amount': line.debit or line.credit,
                    'debit': line.debit,
                    'credit': line.credit,
                    'partner_id': line.partner_id,
                    'name': line.name or 'Intercompany Payment',
                    'analytic_distribution': line.analytic_distribution,
                }

                result[target_company].append(line_data)

                _logger.debug(
                    'Found related party line: Account=%s, Amount=%s, Partner=%s',
                    line.account_id.code,
                    line.debit or line.credit,
                    line.partner_id.name if line.partner_id else 'None'
                )

        return result

    def _create_entry_for_company(self, target_company, lines_data):
        """
        Create a journal entry in the target company.

        Args:
            target_company: res.company record
            lines_data: list of dicts containing line information

        Returns:
            account.move: The created journal entry
        """
        self.ensure_one()

        # Get configuration (same for all lines to this company)
        config = lines_data[0]['config']
        journal = config.journal_id

        # Prepare move values
        move_vals = {
            'company_id': target_company.id,
            'journal_id': journal.id,
            'date': self.date,
            'ref': _('Intercompany from %s - %s') % (self.company_id.name, self.name),
            'skip_intercompany': True,  # CRITICAL: Prevent infinite loop!
            'source_intercompany_move_id': self.id,
            'move_type': 'entry',
            'line_ids': [],
        }

        # Prepare move lines
        move_lines = []

        for line_data in lines_data:
            config = line_data['config']
            line = line_data['line']

            # 1. Related Party line (opposite side)
            rp_line_vals = {
                'account_id': config.target_account_id.id,
                'name': line_data['name'],
                'partner_id': False,  # Related Party accounts typically don't have partners
                'debit': line_data['credit'],  # Opposite!
                'credit': line_data['debit'],  # Opposite!
                'analytic_distribution': line_data.get('analytic_distribution'),
            }
            move_lines.append((0, 0, rp_line_vals))

            # 2. Supplier/Partner line (same side)
            # Need to determine the correct account for the partner in target company
            partner = line_data['partner_id']

            if partner:
                # Get partner's payable/receivable account in target company
                partner_account = self._get_partner_account_in_company(
                    partner,
                    target_company,
                    line_data['debit'] > 0  # True if debit (payable), False if credit (receivable)
                )

                if partner_account:
                    partner_line_vals = {
                        'account_id': partner_account.id,
                        'name': line_data['name'],
                        'partner_id': partner.id,
                        'debit': line_data['debit'],
                        'credit': line_data['credit'],
                        'analytic_distribution': line_data.get('analytic_distribution'),
                    }
                    move_lines.append((0, 0, partner_line_vals))
                else:
                    _logger.warning(
                        'Could not find partner account for %s in company %s',
                        partner.name,
                        target_company.name
                    )
            else:
                # If no partner, use the same account from the original line
                # but in the target company
                original_account = line.account_id
                target_account = self._find_similar_account_in_company(
                    original_account,
                    target_company
                )

                if target_account:
                    other_line_vals = {
                        'account_id': target_account.id,
                        'name': line_data['name'],
                        'partner_id': False,
                        'debit': line_data['debit'],
                        'credit': line_data['credit'],
                        'analytic_distribution': line_data.get('analytic_distribution'),
                    }
                    move_lines.append((0, 0, other_line_vals))

        # Add lines to move
        move_vals['line_ids'] = move_lines

        # Create the move in target company context
        new_move = self.env['account.move'].with_company(target_company).sudo().create(move_vals)

        # Auto-post if configured
        if config.auto_post:
            try:
                new_move.action_post()
                _logger.info('Auto-posted intercompany move: %s', new_move.name)
            except Exception as e:
                _logger.error(
                    'Failed to auto-post intercompany move %s: %s',
                    new_move.name,
                    str(e)
                )

        return new_move

    def _get_partner_account_in_company(self, partner, company, is_payable=True):
        """
        Get the appropriate partner account (payable/receivable) in target company.

        Args:
            partner: res.partner record
            company: res.company record
            is_payable: True for payable, False for receivable

        Returns:
            account.account: The partner account in the target company
        """
        # Switch to target company context
        partner_in_company = partner.with_company(company)

        if is_payable:
            return partner_in_company.property_account_payable_id
        else:
            return partner_in_company.property_account_receivable_id

    def _find_similar_account_in_company(self, source_account, target_company):
        """
        Try to find a similar account in the target company.

        This method attempts to find an account with the same code or type
        in the target company.

        Args:
            source_account: account.account record
            target_company: res.company record

        Returns:
            account.account: Similar account in target company, or False
        """
        # First try: exact code match
        # In Odoo 18, account.account uses company_ids (Many2many) instead of company_id
        similar_account = self.env['account.account'].search([
            ('company_ids', 'in', target_company.id),
            ('code', '=', source_account.code),
        ], limit=1)

        if similar_account:
            return similar_account

        # Second try: same account type
        # In Odoo 18, account.account uses company_ids (Many2many) instead of company_id
        similar_account = self.env['account.account'].search([
            ('company_ids', 'in', target_company.id),
            ('account_type', '=', source_account.account_type),
        ], limit=1)

        return similar_account

    def _notify_intercompany_error(self, error_message):
        """
        Create a notification/activity for users when intercompany creation fails.

        Args:
            error_message: str - The error message to display
        """
        self.ensure_one()

        # Create an activity for the responsible user
        self.activity_schedule(
            'mail.mail_activity_data_warning',
            summary=_('Intercompany Entry Creation Failed'),
            note=_(
                'Failed to create intercompany entries for journal entry %s.\n\n'
                'Error: %s\n\n'
                'Please check the intercompany configuration and create the entries manually.'
            ) % (self.name, error_message),
            user_id=self.env.user.id,
        )

    def action_view_related_intercompany_moves(self):
        """
        Smart button action to view related intercompany moves.

        Returns:
            dict: Action to open related moves
        """
        self.ensure_one()

        action = self.env['ir.actions.act_window']._for_xml_id('account.action_move_journal_line')

        related_move_ids = self.related_intercompany_move_ids.ids

        if len(related_move_ids) > 1:
            action['domain'] = [('id', 'in', related_move_ids)]
        elif len(related_move_ids) == 1:
            form_view = [(self.env.ref('account.view_move_form').id, 'form')]
            action['views'] = form_view
            action['res_id'] = related_move_ids[0]
        else:
            action = {'type': 'ir.actions.act_window_close'}

        return action